GL_ALPHA_TEST
If enabled, do alpha testing. See glAlphaFunc.

GL_AUTO_NORMAL
If enabled, generate normal vectors when either GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4 is used to generate vertices. See glMap2.

GL_BLEND
If enabled, blend the computed fragment color values with the values in the color buffers. See glBlendFunc.

GL_CLIP_PLANEi
If enabled, clip geometry against user-defined clipping plane i. See glClipPlane.

GL_COLOR_LOGIC_OP
If enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See glLogicOp.

GL_COLOR_MATERIAL
If enabled, have one or more material parameters track the current color. See glColorMaterial.

GL_COLOR_SUM
If enabled and no fragment shader is active, add the secondary color value to the computed fragment color. See glSecondaryColor.

GL_COLOR_TABLE
If enabled, perform a color table lookup on the incoming RGBA color values. See glColorTable.

GL_CONVOLUTION_1D
If enabled, perform a 1D convolution operation on incoming RGBA color values. See glConvolutionFilter1D.

GL_CONVOLUTION_2D
If enabled, perform a 2D convolution operation on incoming RGBA color values. See glConvolutionFilter2D.

GL_CULL_FACE
If enabled, cull polygons based on their winding in window coordinates. See glCullFace.

GL_DEPTH_TEST
If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See glDepthFunc and glDepthRange.

GL_DITHER
If enabled, dither color components or indices before they are written to the color buffer.

GL_FOG
If enabled and no fragment shader is active, blend a fog color into the post-texturing color. See glFog.

GL_HISTOGRAM
If enabled, histogram incoming RGBA color values. See glHistogram.

GL_INDEX_LOGIC_OP
If enabled, apply the currently selected logical operation to the incoming index and color buffer indices. See glLogicOp.

GL_LIGHTi
If enabled, include light i in the evaluation of the lighting equation. See glLightModel and glLight.

GL_LIGHTING
If enabled and no vertex shader is active, use the current lighting parameters to compute the vertex color or index. Otherwise, simply associate the current color or index with each vertex. See glMaterial, glLightModel, and glLight.

GL_LINE_SMOOTH
If enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See glLineWidth.

GL_LINE_STIPPLE
If enabled, use the current line stipple pattern when drawing lines. See glLineStipple.

GL_MAP1_COLOR_4
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate RGBA values. See glMap1.

GL_MAP1_INDEX
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate color indices. See glMap1.

GL_MAP1_NORMAL
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate normals. See glMap1.

GL_MAP1_TEXTURE_COORD_1
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate s texture coordinates. See glMap1.

GL_MAP1_TEXTURE_COORD_2
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate s and t texture coordinates. See glMap1.

GL_MAP1_TEXTURE_COORD_3
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate s, t, and r texture coordinates. See glMap1.

GL_MAP1_TEXTURE_COORD_4
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate s, t, r, and q texture coordinates. See glMap1.

GL_MAP1_VERTEX_3
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate x, y, and z vertex coordinates. See glMap1.

GL_MAP1_VERTEX_4
If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 generate homogeneous x, y, z, and w vertex coordinates. See glMap1.

GL_MAP2_COLOR_4
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate RGBA values. See glMap2.

GL_MAP2_INDEX
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate color indices. See glMap2.

GL_MAP2_NORMAL
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate normals. See glMap2.

GL_MAP2_TEXTURE_COORD_1
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate s texture coordinates. See glMap2.

GL_MAP2_TEXTURE_COORD_2
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate s and t texture coordinates. See glMap2.

GL_MAP2_TEXTURE_COORD_3
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate s, t, and r texture coordinates. See glMap2.

GL_MAP2_TEXTURE_COORD_4
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate s, t, r, and q texture coordinates. See glMap2.

GL_MAP2_VERTEX_3
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate x, y, and z vertex coordinates. See glMap2.

GL_MAP2_VERTEX_4
If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 generate homogeneous x, y, z, and w vertex coordinates. See glMap2.

GL_MINMAX
If enabled, compute the minimum and maximum values of incoming RGBA color values. See glMinmax.

GL_MULTISAMPLE
If enabled, use multiple fragment samples in computing the final color of a pixel. See glSampleCoverage.

GL_NORMALIZE
If enabled and no vertex shader is active, normal vectors are normalized to unit length after transformation and before lighting. This method is generally less efficient than GL_RESCALE_NORMAL. See glNormal and glNormalPointer.

GL_POINT_SMOOTH
If enabled, draw points with proper filtering. Otherwise, draw aliased points. See glPointSize.

GL_POINT_SPRITE
If enabled, calculate texture coordinates for points based on texture environment and point parameter settings. Otherwise texture coordinates are constant across points.

GL_POLYGON_OFFSET_FILL
If enabled, and if the polygon is rendered in GL_FILL mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See glPolygonOffset.

GL_POLYGON_OFFSET_LINE
If enabled, and if the polygon is rendered in GL_LINE mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See glPolygonOffset.

GL_POLYGON_OFFSET_POINT
If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in GL_POINT mode. See glPolygonOffset.

GL_POLYGON_SMOOTH
If enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.

GL_POLYGON_STIPPLE
If enabled, use the current polygon stipple pattern when rendering polygons. See glPolygonStipple.

GL_POST_COLOR_MATRIX_COLOR_TABLE
If enabled, perform a color table lookup on RGBA color values after color matrix transformation. See glColorTable.

GL_POST_CONVOLUTION_COLOR_TABLE
If enabled, perform a color table lookup on RGBA color values after convolution. See glColorTable.

GL_RESCALE_NORMAL
If enabled and no vertex shader is active, normal vectors are scaled after transformation and before lighting by a factor computed from the modelview matrix. If the modelview matrix scales space uniformly, this has the effect of restoring the transformed normal to unit length. This method is generally more efficient than GL_NORMALIZE. See glNormal and glNormalPointer.

GL_SAMPLE_ALPHA_TO_COVERAGE
If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.

GL_SAMPLE_ALPHA_TO_ONE
If enabled, each sample alpha value is replaced by the maximum representable alpha value.

GL_SAMPLE_COVERAGE
If enabled, the fragment's coverage is ANDed with the temporary coverage value. If GL_SAMPLE_COVERAGE_INVERT is set to GL_TRUE, invert the coverage value. See glSampleCoverage.

GL_SEPARABLE_2D
If enabled, perform a two-dimensional convolution operation using a separable convolution filter on incoming RGBA color values. See glSeparableFilter2D.

GL_SCISSOR_TEST
If enabled, discard fragments that are outside the scissor rectangle. See glScissor.

GL_STENCIL_TEST
If enabled, do stencil testing and update the stencil buffer. See glStencilFunc and glStencilOp.

GL_TEXTURE_1D
If enabled and no fragment shader is active, one-dimensional texturing is performed (unless two- or three-dimensional or cube-mapped texturing is also enabled). See glTexImage1D.

GL_TEXTURE_2D
If enabled and no fragment shader is active, two-dimensional texturing is performed (unless three-dimensional or cube-mapped texturing is also enabled). See glTexImage2D.

GL_TEXTURE_3D
If enabled and no fragment shader is active, three-dimensional texturing is performed (unless cube-mapped texturing is also enabled). See glTexImage3D.

GL_TEXTURE_CUBE_MAP
If enabled and no fragment shader is active, cube-mapped texturing is performed. See glTexImage2D.

GL_TEXTURE_GEN_Q
If enabled and no vertex shader is active, the q texture coordinate is computed using the texture generation function defined with glTexGen. Otherwise, the current q texture coordinate is used. See glTexGen.

GL_TEXTURE_GEN_R
If enabled and no vertex shader is active, the r texture coordinate is computed using the texture generation function defined with glTexGen. Otherwise, the current r texture coordinate is used. See glTexGen.

GL_TEXTURE_GEN_S
If enabled and no vertex shader is active, the s texture coordinate is computed using the texture generation function defined with glTexGen. Otherwise, the current s texture coordinate is used. See glTexGen.

GL_TEXTURE_GEN_T
If enabled and no vertex shader is active, the t texture coordinate is computed using the texture generation function defined with glTexGen. Otherwise, the current t texture coordinate is used. See glTexGen.

GL_VERTEX_PROGRAM_POINT_SIZE
If enabled and a vertex shader is active, then the derived point size is taken from the (potentially clipped) shader builtin gl_PointSize and clamped to the implementation-dependent point size range.

GL_VERTEX_PROGRAM_TWO_SIDE
If enabled and a vertex shader is active, it specifies that the GL will choose between front and back colors based on the polygon's face direction of which the vertex being shaded is a part. It has no effect on points or lines.